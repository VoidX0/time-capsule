import fs from 'fs'
import path from 'path'
import { Project } from 'ts-morph'
import { fileURLToPath } from 'url'

// 解决 ESM 下 __dirname
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// 初始化 ts-morph
const project = new Project({
  tsConfigFilePath: path.resolve(__dirname, '../tsconfig.json'),
})

// 加载 schema.d.ts
const source = project.addSourceFileAtPath(
  path.resolve(__dirname, '../src/api/schema.d.ts'),
)

/**
 * 将 JSDoc 转换为字符串
 * @param comment
 */
function commentToString(
  comment:
    | string
    | (
        | import('ts-morph').JSDocText
        | import('ts-morph').JSDocLink
        | import('ts-morph').JSDocLinkCode
        | import('ts-morph').JSDocLinkPlain
        | undefined
      )[]
    | undefined,
): string | undefined {
  if (!comment) return undefined
  if (typeof comment === 'string') return comment
  return comment
    .map((c) => c?.getText())
    .filter(Boolean)
    .join('')
}

/**
 * 提取指定类型的字段信息
 * @param typeName
 */
function extractType(typeName: string) {
  // 提取components
  const componentsInterface = source.getInterface('components')
  if (!componentsInterface) return {}
  // 提取schemas
  const schemasProp = componentsInterface.getProperty('schemas')
  if (!schemasProp) return {}
  // 提取schemas的类型
  const schemasType = schemasProp.getType()
  // 提取目标类型
  const targetSymbol = schemasType.getProperty(typeName)
  if (!targetSymbol) return {}
  // 提取目标类型的字段
  const declarations = targetSymbol.getDeclarations()
  if (!declarations || declarations.length === 0) return {}
  // 仅处理第一个声明
  const firstDecl = declarations[0]!
  const targetType = firstDecl.getType()
  const props = targetType.getProperties()
  const result: Record<string, unknown> = {}
  // 提取字段信息
  props.forEach((prop) => {
    const name = prop.getName() // 字段名称
    const valueType = prop.getTypeAtLocation(firstDecl).getText() // 字段类型
    // 提取 JSDoc 信息
    let description: string | undefined = undefined
    let format: string | undefined = undefined
    // 获取属性的声明以提取 JSDoc
    const decls = prop.getDeclarations()
    if (decls && decls.length > 0) {
      const decl = decls[0] as import('ts-morph').PropertySignature
      const jsDocs = decl.getJsDocs()
      // 遍历所有 JSDoc
      jsDocs.forEach((doc) => {
        // 先获取 doc.getComment() 字符串化
        const docComment = commentToString(doc.getComment())
        // 提取 Format
        if (docComment) {
          const match = docComment.match(/Format:\s*(.+)/)
          if (match) format = match[1]
        }
        // 获取 @description 标签
        const descTag = doc
          .getTags()
          .find((t) => t.getTagName() === 'description')
        if (descTag) {
          description = commentToString(descTag.getComment())
        }
      })
    }
    // 保存字段信息
    result[name] = { type: valueType, description, format }
  })

  return result
}

/**
 * 获取所有 schema 类型名称
 */
function getAllSchemaNames(): string[] {
  // 提取components
  const componentsInterface = source.getInterface('components')
  if (!componentsInterface) return []
  // 提取schemas
  const schemasProp = componentsInterface.getProperty('schemas')
  if (!schemasProp) return []
  // 提取schemas的类型
  const schemasType = schemasProp.getType()
  const symbols = schemasType.getProperties()
  // 返回名称
  return symbols.map((s) => s.getName())
}

// 生成 runtime schema 对象
const schemaNames = getAllSchemaNames()
const schemas: Record<string, unknown> = {}
schemaNames.forEach((name) => {
  schemas[name] = extractType(name)
})

// 写入文件
const outputPath = path.resolve(__dirname, '../src/api/generatedSchemas.ts')
fs.writeFileSync(
  outputPath,
  `/**
 * This file is auto-generated by scripts/generateSchema.ts
 * Do not edit manually
 */
export const schemas = ${JSON.stringify(schemas, null, 2)};
`,
)

console.log(`✅ Runtime schemas generated at ${outputPath}\n`)
